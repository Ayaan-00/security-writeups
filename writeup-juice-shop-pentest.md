# Chaining Vulnerabilities on OWASP Juice Shop: From Reconnaissance to Full Application Compromise

Ayaan Mohammed

Tools: Burp Suite, Browser DevTools, Kali Linux, Docker | Target: OWASP Juice Shop (localhost lab environment)

---

## Why This Writeup Exists

Every writeup I have done so far covers a single vulnerability class. SQL injection in one place, authentication flaws in another, access control somewhere else. But it is not how real penetration tests work.
In an actual engagement, findings do not exist in isolation. One finding feeds the next, and the value of the assessment comes from connecting them into an attack narrative that shows the client exactly how an attacker would move through their application.

This writeup is different from my others because it follows that approach. Instead of documenting individual challenges, it walks through OWASP Juice Shop as a single continuous engagement. Reconnaissance first, then targeted exploitation based on what reconnaissance revealed, then escalation based on what exploitation uncovered. Each phase builds on the last. The goal is to demonstrate the methodology and thought process behind chaining vulnerabilities, not just the technical execution of any single one.

Everything documented here was performed locally in Docker on my own machine. No production systems were tested.

---

## Phase 1: Reconnaissance and Attack Surface Mapping

### Technology Fingerprinting

Before touching the login page or trying a single payload, I needed to understand what the application was built on. The technology stack determines what types of attacks are viable, what default behaviors to expect, and where the application is most likely to break.

The first thing I checked was the application's error handling. I navigated to a nonexistent endpoint and watched what came back. The response header and error page revealed the application was running on Express, a Node.js web framework. That single detail immediately narrowed the scope. Express applications typically use middleware like Helmet for security headers, Sequelize or similar ORMs for database interaction, and JWT for session management. Each of those carries known weakness patterns.

### FTP Directory Listing

While mapping the application's structure, I discovered an open /ftp directory. No authentication required. The directory contained files that should never be publicly accessible: `package.json.bak`, `coupons_2013.md.bak`, `acquisitions.md`, `announcement_encrypted.md`, `incident-support.kdbx`, and `suspicious_errors.yml`.

On a real engagement, this is the kind of finding that changes the entire trajectory of the assessment. An exposed backup of `package.json` is not just an information disclosure issue. It is a roadmap.

### Extracting the Technology Stack

I downloaded `package.json.bak` and opened it on my Kali machine. The file contained the application's complete dependency manifest, both production and development dependencies with version numbers.

What stood out immediately:

`express` version ~4.16 confirmed the framework. `sequelize` ~4 and `sqlite3` ~3.1.13 confirmed the ORM and database engine. The application was running SQLite on the backend, which means SQL injection payloads need to be tuned for SQLite syntax rather than MySQL or PostgreSQL. That matters because SQLite handles UNION queries, comment syntax, and type coercion differently.

`jsonwebtoken` ~8 confirmed JWT based session management. This means session tokens are not server side session IDs but signed tokens that can potentially be decoded, forged, or exploited through algorithm confusion attacks.

`sanitize-html` version 1.4.2 was listed as a dependency. This is the library responsible for preventing cross site scripting. Version 1.4.2 is years behind the current release. Outdated sanitization libraries are a strong indicator that XSS bypasses may be possible.

`helmet` ~3.9 was present, which is Express middleware for setting security headers. Its presence suggested some headers would be configured, but older versions of Helmet do not enable all protections by default.

`marsdb` ~0.6, `express-jwt` 0.1.3, and `z85` ~0.0 were also present. The extremely low version numbers of some packages combined with the overall age of the dependency tree painted a clear picture: this application had significant technical debt with dependencies that had not been updated in a long time.

The development dependencies revealed the testing stack: `karma`, `jasmine`, `protractor`, `jest`, `frisby` for API testing. Knowing the test frameworks is less immediately exploitable but confirms the application has API endpoints worth investigating, since `frisby` is specifically an API testing library.

This single file gave me more actionable intelligence than an hour of automated scanning would have. I now knew the database engine, the session mechanism, the sanitization library and its version, and the overall security posture of the dependency chain. Every exploit that followed was informed by this reconnaissance.

### Probing File Access Controls

The /ftp directory accepted direct file downloads for .md and .pdf files. I wanted to test whether the file server validated path inputs or just checked file extensions. I attempted a path traversal by requesting `/ftp/....//....//etc/passwd`.

The application returned a 403 error, which means the path traversal was partially blocked. But the error response was more valuable than a successful file read would have been. The server returned a verbose Express stack trace that exposed:

The internal file path structure: `/juice-shop/build/routes/fileServer.js` at line 55. The validation function name: `verify`. The full call stack through Express's router middleware, revealing the internal routing architecture. The Node.js `fs` module was being called directly, confirming server side file operations.

The 403 with "Only .md and .pdf files are allowed!" also revealed the exact file type restriction logic. This is useful because it tells an attacker precisely what bypass they need to construct. A null byte injection, a double extension, or encoding tricks could potentially circumvent a simple extension check.

On a real engagement, this gets written up as two findings: the path traversal that was partially blocked (positive), and the verbose error disclosure that leaked internal architecture (negative). The stack trace gives an attacker structural knowledge they should never have.

---

## Phase 2: Authentication Bypass

### SQL Injection on the Login Form

With the technology stack mapped and SQLite confirmed as the backend database, I moved to the login form. SQL injection against authentication is the highest value target because successful exploitation gives you access to the application as a legitimate user without needing any credentials.

I entered `' OR 1=1--` as the email field and any string as the password. The application authenticated me as the administrator.

What happened behind the scenes: the login query was likely constructed as something like `SELECT * FROM Users WHERE email = '' OR 1=1--' AND password = '...'`. The injected payload makes the WHERE clause always true, and the comment sequence removes the password check entirely. The query returns all users, and the application logs in as the first row, which is typically the admin account.

This confirmed three things. First, user input on the login form is concatenated directly into SQL queries without parameterization. Second, the application does not use prepared statements or an ORM's built in escaping for authentication queries. Third, the first user in the database is the administrator account (admin@juice-sh.op), which is a common pattern in applications that seed an admin user during initial setup.

The Login Admin challenge was solved. But more importantly, I now had authenticated access to the application as the highest privileged user, which opened the door to everything that followed.

---

## Phase 3: Data Extraction

### UNION Based SQL Injection via Search

Having confirmed that the application is vulnerable to SQL injection on the login form, I hypothesized that other input fields interacting with the database would have the same weakness. The search functionality was the obvious next target.

The search bar on Juice Shop queries the product database. I tested it with the same injection approach, but this time with a UNION SELECT payload designed to extract data from a different table entirely.

The payload I used in the search bar:

```
qwert')) UNION ALL SELECT NULL,email,password,NULL,NULL,NULL,NULL,NULL,NULL FROM Users--
```

Breaking this down: `qwert'))` closes the original query's string literal and any surrounding parentheses. `UNION ALL SELECT` appends a second query to the original results. The NULL columns are placeholders that match the column count of the products table. `email,password` are the two columns I wanted from the Users table. `FROM Users--` targets the Users table and comments out the rest.

The response came back with all user email addresses and their corresponding password hashes displayed in the search results where product names would normally appear. Every user account in the database was now enumerated, complete with hashed credentials.

This is the finding that would stop a real engagement for an emergency disclosure call. An attacker with this data can take the password hashes offline, crack them at their own pace, and gain access to every account in the system. Combined with the admin access already achieved through the login bypass, this means complete compromise of all user data.

### Why the Search Endpoint Mattered More

This is worth pausing on. You do not stop after the first finding. The login form SQLi proved the vulnerability class exists. A thorough tester asks "where else?" The answer was the search endpoint, and the impact was worse because it allowed direct data extraction rather than just authentication bypass.

---

## Phase 4: Injection Across Endpoints

### SQL Injection in Order Tracking

After confirming SQL injection on both the login form and the search functionality, I tested the order tracking API. The endpoint `/rest/track-order/` accepts an order ID and returns tracking information.

I submitted a crafted input through the URL:

```
/rest/track-order/' %7C%7C true %7C%7C'
```

The URL decoded payload is `' || true ||'`, which is a SQLite specific boolean injection. The double pipe is SQLite's concatenation operator, and injecting `true` into the query forces it to evaluate as truthy regardless of the actual order ID.

The response came back:

```json
{"status":"success","data":[{"orderId":"true"}]}
```

The application returned a success response with the injected boolean value reflected in the orderId field. This confirmed that the order tracking endpoint is also vulnerable to injection and that it directly reflects query results in the API response.

Three separate injection points across three different application features: login, search, and order tracking. This pattern tells you the vulnerability is systemic. It is not a single developer's mistake on one form. It is an architectural decision to build queries through string concatenation throughout the entire application. Fixing this requires parameterized queries everywhere, not just patching individual endpoints.

---

## Phase 5: Error Handling and Information Disclosure

### Verbose Stack Traces

Throughout the assessment, the application consistently returned detailed error information when requests failed. The most revealing instance was the path traversal attempt against the /ftp endpoint, which returned a full Express stack trace including internal file paths, function names, and the Node.js module chain.

But this was not an isolated case. Malformed requests to API endpoints, invalid JSON in POST bodies, and requests to nonexistent routes all produced verbose error responses. The application was running in what appeared to be a development or debug configuration, with error handling middleware that exposes internals to the client.

In production, this is a serious misconfiguration. Stack traces reveal the framework version, internal directory structure, middleware ordering, and sometimes database connection strings or environment variables. An attacker uses this to refine their payloads and map the application's internals without needing source code access.

This falls under OWASP Top 10 A05:2021 Security Misconfiguration. The fix is a custom error handler that returns generic messages to clients while logging detailed errors server side.

---

## The Attack Chain

This is what makes this assessment different from running individual labs. Each finding enabled the next:

The open /ftp directory led to the exposed `package.json.bak`. The package manifest revealed SQLite as the database engine and the full technology stack. Knowing SQLite allowed me to craft targeted SQL injection payloads for the login form. Successful authentication bypass as admin confirmed injection was possible and gave authenticated access. Authenticated access combined with known SQLite syntax enabled UNION based data extraction through the search function. Confirming injection on login and search led me to test the order tracking API, revealing a third injection point. Throughout, verbose error responses provided architectural intelligence that informed payload construction at every step.

Remove any single link in that chain and the assessment looks different. Without the package.json leak, I would have needed to fingerprint the database engine through blind injection techniques, adding hours of work. Without confirming the column count from the products table through trial and error with NULLs, the UNION extraction would not have worked on the first attempt. Without the error responses leaking internal paths, I would have had less confidence in the application's architecture.

A vulnerability scanner would have flagged each of these individually. Missing headers, injection on forms, information disclosure. But it would not have connected them into a narrative that shows a client exactly how an attacker moves from initial access to full database compromise in a single session. That narrative is what changes remediation priorities. It is the difference between a client fixing one form and a client rebuilding their query layer.

---

## Findings Summary

| Finding | Severity | OWASP Top 10 | CWE |
|---------|----------|--------------|-----|
| SQL injection on login (authentication bypass) | Critical | A03:2021 Injection | CWE-89 |
| UNION-based SQLi on search (full credential extraction) | Critical | A03:2021 Injection | CWE-89 |
| SQL injection on order tracking API | High | A03:2021 Injection | CWE-89 |
| Open FTP directory with sensitive files | High | A01:2021 Broken Access Control | CWE-538 |
| Exposed package.json.bak (full dependency disclosure) | Medium | A05:2021 Security Misconfiguration | CWE-200 |
| Verbose error responses with stack traces | Medium | A05:2021 Security Misconfiguration | CWE-209 |
| Path traversal partially blocked but file restriction logic disclosed | Low | A01:2021 Broken Access Control | CWE-22 |

---

## Remediation Priorities

The injection vulnerabilities are systemic and require an architectural fix, not individual patches. Every database query in the application should use parameterized queries or the ORM's built in escaping. This is not a recommendation to fix three endpoints. It is a recommendation to audit and rebuild the entire data access layer.

The dependency chain needs a full audit. Running `npm audit` against the extracted package.json would likely return dozens of known vulnerabilities across the outdated packages. A dependency update and lock file review should be part of the remediation plan.

The /ftp directory should not be publicly accessible. If file serving is required, it should be behind authentication with a whitelist of permitted files rather than a blacklist of blocked extensions.

Error handling should be reconfigured for production. Custom error middleware should catch all exceptions and return generic messages to clients. Detailed errors should be logged server side only. The Express `NODE_ENV` should be set to `production` to suppress stack traces.

---

## Lessons Learned

Reconnaissance determines everything. Spending time on the /ftp directory and the package.json file before attempting any exploitation made every subsequent attack faster and more targeted. In a time boxed engagement, that upfront investment pays for itself many times over.

One vulnerability class, tested everywhere, tells a bigger story than many classes tested once. Finding SQL injection on three separate endpoints elevated this from "the login form has a bug" to "the application has a systemic injection problem." That changes the remediation conversation from patching to rebuilding.

The "so what" lives in the chain, not the individual finding. An open FTP directory is a medium severity finding. An open FTP directory that leaks the database engine, which enables targeted SQL injection, which leads to full credential extraction, is a critical attack path. Pentest reports that show chains get remediation budgets. Reports that list individual findings get filed away.

Error messages are intelligence. Every verbose error response I received during this assessment gave me information that refined the next step. Attackers treat error messages as documentation. Developers should treat them the same way and make sure they only document what they want an attacker to know.

---

## Tools Used

- [Burp Suite](https://portswigger.net/burp) for request interception, payload crafting, and response analysis
- [OWASP Juice Shop](https://owasp.org/www-project-juice-shop/) as the target application
- [Docker](https://www.docker.com/) for isolated lab environment
- [Kali Linux](https://www.kali.org/) as the testing platform
- Browser DevTools for client side analysis and network inspection

---

## About Me

Cybersecurity professional based in Toronto. MS in Information Systems Security Management from Northeastern University. My experience includes SOC operations, penetration testing, and web application security assessments across multiple sectors. Active participant in the OWASP community, building offensive security skills through PortSwigger Web Security Academy and HackTheBox.

[LinkedIn](https://www.linkedin.com/in/ayaan-m-2643122a0/)

---

*This writeup documents exploitation of OWASP Juice Shop, a deliberately vulnerable training application. No production systems were tested. All work was performed locally in Docker.*
